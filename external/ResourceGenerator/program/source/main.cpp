#include "main.hpp"

#include <algorithm>
#include <cstddef>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#define STB_IMAGE_IMPLEMENTATION
#include "stb/stb_image.h"

int main(int argc, char *argv[])
{
  std::vector<std::string> valid_text_extensions = {"glsl", "frag", "vert"};
  std::vector<std::string> valid_image_extensions = {"png"};

  std::vector<std::filesystem::path> paths;
  for (int index = 3; index < argc - 1; index++) paths.push_back(std::filesystem::path(argv[index]));
  std::vector<Resource> resources;
  for (auto &path : paths)
  {
    std::string name = path.filename().replace_extension("").string();
    std::string extension = path.extension().string().substr(1);

    bool is_text =
      std::find(valid_text_extensions.begin(), valid_text_extensions.end(), extension) != valid_text_extensions.end();
    bool is_image = std::find(valid_image_extensions.begin(), valid_image_extensions.end(), extension) !=
                    valid_image_extensions.end();
    if (is_text)
    {
      std::ifstream file(path, std::ios::binary | std::ios::ate);
      if (!file.is_open()) { return 1; }
      std::streamsize size = file.tellg();
      file.seekg(0, std::ios::beg);
      std::vector<unsigned char> buffer((size_t)size + 1);
      if (!file.read((char *)buffer.data(), size)) { return 1; }
      buffer[(size_t)size] = 0x00;
      resources.push_back({path, name, extension, buffer});
    }
    else if (is_image)
    {
      int width, height, channels;
      stbi_set_flip_vertically_on_load(true);
      unsigned char *data = stbi_load(path.string().c_str(), &width, &height, &channels, 0);
      if (data == nullptr) return 1;
      std::vector<unsigned char> binary(data, data + size_t(width * height * channels));
      resources.push_back({path, name, extension, binary, width, height, channels});
      stbi_image_free(data);
    }
    else
      return 1;
  }

  std::string path = argv[argc - 1];
  std::string name = "";
  if (path.find_last_of("/") != std::string::npos)
    name = path.substr(path.find_last_of("/") + 1, path.find_last_of(".") - path.find_last_of("/") - 1);
  else
    name = path.substr(0, path.find_last_of("."));
  std::string extension = path.substr(path.find_last_of(".") + 1);
  Configuration config = {resources, path, name, extension, argv[1], argv[2]};

  std::string output_content = "";
  if (config.extension == "cpp")
  {
    output_content += "// This is an autogenerated file, do not edit.\n\n#include \"" + config.name +
                      ".hpp\"\n#include \"object.hpp\"\n\nnamespace cse::resource\n{";
    for (auto &resource : config.resources)
    {
      bool is_text = std::find(valid_text_extensions.begin(), valid_text_extensions.end(), resource.extension) !=
                     valid_text_extensions.end();
      bool is_image = std::find(valid_image_extensions.begin(), valid_image_extensions.end(), resource.extension) !=
                      valid_image_extensions.end();
      if (is_text) output_content += "\n  const char " + resource.name + config.text_postfix + "[] = {\n  ";
      if (is_image) output_content += "\n  const unsigned char " + resource.name + "_array[] = {\n  ";
      int count = 0;
      for (auto &character : resource.binary)
      {
        output_content += unsigned_char_to_hex(character);
        bool is_last = !((size_t)count < resource.binary.size() - 1);
        bool is_end = (count + 1) % 16 == 0;
        if (!is_last) output_content += is_end ? "," : ", ";
        if (is_end && !is_last) output_content += "\n  ";
        count++;
      }
      output_content += " };\n";
      if (is_image)
        output_content += "  const object::Texture_data " + resource.name + config.image_postfix + " = { " +
                          resource.name + "_array, " + std::to_string(resource.width) + ", " +
                          std::to_string(resource.height) + ", " + std::to_string(resource.channels) + " };\n";
      if (!is_text && !is_image) return 1;
    }
  }
  else if (config.extension == "hpp")
  {
    output_content += "// This is an autogenerated file, do not edit.\n\n#pragma once\n\n#include "
                      "\"object.hpp\"\n\nnamespace cse::resource\n{";
    for (auto &resource : config.resources)
    {
      bool is_text = std::find(valid_text_extensions.begin(), valid_text_extensions.end(), resource.extension) !=
                     valid_text_extensions.end();
      bool is_image = std::find(valid_image_extensions.begin(), valid_image_extensions.end(), resource.extension) !=
                      valid_image_extensions.end();
      if (is_text) output_content += "\n  extern const char " + resource.name + config.text_postfix + "[];";
      if (is_image)
        output_content += "\n  extern const object::Texture_data " + resource.name + config.image_postfix + ";";
    }
    output_content += "\n";
  }
  else
    return 1;

  std::ofstream output_file(config.path);
  if (!output_file.is_open()) return 1;
  output_file << output_content + "}";
  output_file.close();
  return 0;
}

std::string unsigned_char_to_hex(unsigned char character)
{
  std::stringstream ss;
  ss << "0x" << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(character);
  return ss.str();
}
